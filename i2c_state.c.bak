/* Microchip Technology Inc. and its subsidiaries.  You may use this software 
 * and any derivatives exclusively with Microchip products. 
 * 
 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER 
 * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED 
 * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A 
 * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION 
 * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION. 
 *
 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
 * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
 * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS 
 * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.  TO THE 
 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS 
 * IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF 
 * ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 *
 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE 
 * TERMS. 
 */

#include "i2c_state.h"
#include "delay.h"


/*******************************************************************************
  This source file has NOT been generated by the MHC
 *******************************************************************************/

/* 
 * File:   
 * Author: 
 * Comments:
 * Revision history: 
 */

// *****************************************************************************
// *****************************************************************************
// Section: Included Files 
// *****************************************************************************
// *****************************************************************************



// *****************************************************************************
// *****************************************************************************
// Section: Global Data Definitions
// *****************************************************************************
// *****************************************************************************



tI2CTransmission transmission;
I2C_STATES i2cAppState;
char startI2CTransfer = 0;
char preparedReadEEPROM = 0;
char writeEEPROM = 0;
unsigned char pca9634_data[1];
static unsigned char pos_of_readEEPromBytes;
static unsigned char max_len_of_readEEPromBytes = 8;
static unsigned char byteCounter = 0;
unsigned char rxBuffer_i2c[8];

char wordAdress = 0x50;


/*  
 MODE1, MODE2, PWM0-PWM7, GRPPWM, GRPFREQ, LEDOUT0, LEDOUT1
 */
unsigned char pca9634_config[] = {0, 0, 25, 25, 25, 25, 25, 25, 25, 25, 0, 0, 0xAA, 0xAA };
unsigned char eeprom_data[] = {0x67,0x66,0x65,0x64,0x63,0x62,0x61,0x60};

//unsigned char pca9634_config[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xAA, 0xAA };
// *****************************************************************************
// *****************************************************************************
// Section: User Functions
// *****************************************************************************
// *****************************************************************************
int i2c_Initialize ( void )
{
    i2cTransmitArray(PCA9634_ADDRESS, 0x80 | PCA9634_REG_MODE1, pca9634_config, sizeof(pca9634_config));
    
    return 1;
}

void i2cTurnLED(unsigned char on_off, unsigned char controlReg) {

    pca9634_data[0] = on_off;
    i2cTransmitArray(PCA9634_ADDRESS, controlReg, pca9634_data, sizeof(pca9634_data));
}



char i2cTransmitArray(unsigned char bus_adr, unsigned char int_adr, unsigned char * data, unsigned char data_len)
{
    transmission.bus_adr = bus_adr;
    transmission.int_adr = int_adr;
    transmission.data = data;
    transmission.data_len = data_len;
    
    transmission.pos = 0;
    
    startI2CTransfer = 1;
}

char i2cService(void)
{
    /* I2C - LED Controller */
    if (DRV_I2C0_MasterBusIdle() )
    {
        switch (i2cAppState)
        {
        /* LED will be toggled in Timer Callback function, 
         * so nothing is there to be done in this state */
           
            case I2C_STATE_IDLE:
                if (startI2CTransfer)
                {
                    i2cAppState = I2C_STATE_SEND_START_CONDITION;
                }
                break;

            case I2C_STATE_SEND_START_CONDITION:
                DRV_I2C0_MasterStart();
                DRV_I2C0_WaitForStartComplete();
                i2cAppState = I2C_STATE_SEND_ADDRESS_BYTE;
                break;

            case I2C_STATE_SEND_ADDRESS_BYTE:
                if (DRV_I2C0_ByteWrite(transmission.bus_adr))
                {
                    DRV_I2C0_WaitForByteWriteToComplete(); 
                    if (DRV_I2C0_WriteByteAcknowledged())
                        i2cAppState = I2C_STATE_SEND_DATA;
                    else
                        i2cAppState = I2C_OPERATION_COMPLETE;
                }
                else
                    i2cAppState = I2C_STATE_SEND_ADDRESS_BYTE;
                break;

            case I2C_STATE_SEND_DATA:
                for (transmission.pos = 0; transmission.pos < transmission.data_len; transmission.pos++ )
                {
                    if (transmission.pos == 0)
                        DRV_I2C0_ByteWrite(transmission.int_adr);
                    else
                    {
                        DRV_I2C0_ByteWrite(transmission.data[transmission.pos-1]);
                    }
                    DRV_I2C0_WaitForByteWriteToComplete();
                    
                }
                i2cAppState = I2C_STATE_SEND_STOP_CONDITION;                            
                break;


            case I2C_STATE_SEND_STOP_CONDITION:
                DRV_I2C0_MasterStop();
                DRV_I2C0_WaitForStopComplete();
                delay_nop(5);
                startI2CTransfer = 0;
                i2cAppState = I2C_STATE_IDLE;
                if (preparedReadEEPROM) {
                    i2cAppState = I2C_READ_EEPROM;
                }
                /*else {
                    if (writeEEPROM) {
                        i2cAppState = I2C_WRITE_EEPROM;
                    }
                }*/
                break;
                
            case I2C_READ_SEND_START_CONDITON:
                DRV_I2C0_MasterRestart();
                DRV_I2C0_WaitForStartComplete();
                i2cAppState = I2C_STATE_SEND_READ_ADDRESS_BYTE;
                break;

            case I2C_STATE_SEND_READ_ADDRESS_BYTE:
                if (DRV_I2C0_ByteWrite(transmission.bus_adr))
                {
                    DRV_I2C0_WaitForByteWriteToComplete();
                    if (DRV_I2C0_WriteByteAcknowledged())
                        i2cAppState = I2C_STATE_SEND_DATA;
                    else
                        i2cAppState = I2C_OPERATION_COMPLETE;
                }
                else
                    i2cAppState = I2C_STATE_SEND_READ_ADDRESS_BYTE;
                i2cAppState = I2C_STATE_READ_DATA;
                break;

            case I2C_STATE_READ_DATA:
                pos_of_readEEPromBytes = 0;
                while (pos_of_readEEPromBytes < max_len_of_readEEPromBytes)
                {
                    DRV_I2C0_SetUpByteRead();                   //Set Rx enable in MSTR which causes SLAVE to send data
                    while(!DRV_I2C0_WaitForReadByteAvailable());        // Wait till RBF = 1; Which means data is available in I2C2RCV reg
                    rxBuffer_i2c[pos_of_readEEPromBytes] = DRV_I2C0_ByteRead();   //Read from I2CxRCV
                    if (pos_of_readEEPromBytes < max_len_of_readEEPromBytes-1)
                    {
                        DRV_I2C0_MasterACKSend();               //Send ACK to Slave
                    }
                    while (!DRV_I2C0_WaitForACKOrNACKComplete());
                    pos_of_readEEPromBytes++;
                }
                DRV_I2C0_MasterNACKSend();                      //last byte; send NACK to Slave, no more data needed
                while (!DRV_I2C0_WaitForACKOrNACKComplete());   // wait till NACK sequence is complete i.e ACKEN = 0
                i2cAppState = I2C_STATE_READ_STOP_CONDITION;
                break;

            case I2C_STATE_READ_STOP_CONDITION:
                DRV_I2C0_MasterStop();
                DRV_I2C0_WaitForStopComplete();
                startI2CTransfer = 0;
                i2cAppState = I2C_OPERATION_COMPLETE;
                break;
              
            case I2C_WRITE_EEPROM:
                i2cTransmitArray(EEPROM_WRITE_ADDRESS, wordAdress, eeprom_data, sizeof(eeprom_data)+1);
                i2cAppState = I2C_STATE_SEND_START_CONDITION;
                break;
                
            case I2C_READ_EEPROM:
                if (preparedReadEEPROM) {
                    i2cTransmitArray(EEPROM_READ_ADDRESS, 0, 0, 1);
                    i2cAppState = I2C_READ_SEND_START_CONDITON;
                    preparedReadEEPROM=0;
                } else {
                    i2cTransmitArray(EEPROM_WRITE_ADDRESS, wordAdress, 0, 1);
                    i2cAppState = I2C_STATE_SEND_START_CONDITION;
                    preparedReadEEPROM=1;   
                }
                          
                break;

            case I2C_READ_EEPROM_ID:
                             
                break;
            
            case I2C_OPERATION_COMPLETE:
                //LEDOn(LED_green, PORT_B);
                break;
            default:
                //DBPRINTF("ERROR! Invalid state %d\n", testState);
                while (1);
        }
    }
}

void delay_nop(unsigned int delay)
{
    while (delay > 0) delay--;
    Nop();
}

// Comment a function definition and leverage automatic documentation 
/**
  <p><b>Function:</b></p>

  <p><b>Summary:</b></p>

  <p><b>Description:</b></p>

  <p><b>Remarks:</b></p>
 */
// TODO Insert function definitions (right here) to leverage live documentation
