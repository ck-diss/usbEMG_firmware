/* Microchip Technology Inc. and its subsidiaries.  You may use this software 
 * and any derivatives exclusively with Microchip products. 
 * 
 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER 
 * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED 
 * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A 
 * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION 
 * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION. 
 *
 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
 * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
 * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS 
 * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.  TO THE 
 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS 
 * IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF 
 * ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 *
 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE 
 * TERMS. 
 */

/*******************************************************************************
  This source file has NOT been generated by the MHC
 *******************************************************************************/

/* 
 * File:   
 * Author: 
 * Comments:
 * Revision history: 
 */

// *****************************************************************************
// *****************************************************************************
// Section: Included Files 
// *****************************************************************************
// *****************************************************************************

#include "app.h"
#include "timer_state.h"


TIMER_STATES timerState;
TIMER_DATA timerData;
RUNTIME_DATA runtimeData;

extern I2C_STATES i2cAppState;

// *****************************************************************************
// *****************************************************************************
// Section: Global Data Definitions
// *****************************************************************************
// *****************************************************************************

static char count = 0;
unsigned char countTime = 0;
long long countSeconds = 0;

// Only for testing purpose
// In the actual version, this should be taken from the device
//unsigned int SamplingRate = 8000;

// *****************************************************************************
// *****************************************************************************
// Section: User Functions
// *****************************************************************************
// *****************************************************************************

int Timer_Initialize ( void )
{
    /* Put the application into its initial state */
    timerData.timerState = TIMER_STATE_TIMER_OBJECT_CREATE;
    
    //Only for debugging
    //runtimeData.current = 0x123456; 

    return 1;
}


// A function to calculate the increment of the actual runtime based on the input sampling rate
// The output is time in usec??? or msec???



// *****************************************************************************
// Section: Timer Callback Functions
// *****************************************************************************

// every second
void TimerOneSecondCallBack( void )
{
    // if everything is ok - turn on led green
    //LEDOn(LED_power);
    count++;
    //visual feedback every second
    if (ADS_RECORDING) {
        if (count%2==0) //toggle LED
            LEDOn(LED_status);
        else
            LEDOff(LED_status);
    } 
    else {
        if (ADS_READY) {
            LEDOn(LED_status);
        }
        else {
            LEDOff(LED_status);
        }
    }
    if (DEVICE_ERROR) {
        if (count%2==0) //toggle LED
            LEDOn(LED_power);
        else
            LEDOff(LED_power);    
    }

    i2cTurnAllLED();
    /* Toggle LED */
    if (count<=7) {
        //i2cTurnLED(I2C_LED_OFF, 0x80 | I2C_LED1 + count );
    }        
    else {
        //i2cTurnLED(I2C_LED_ON, 0x80 | I2C_LED1 + (count-8)); // 0x80 -> autoincrement
    }
    //if (count==0) 
//        i2cTurnLED(I2C_LED_ON, 0x80 | 0x11 );

   // 
}

void Timer1CallBack( void )
{
    // This function is used for counting the actual runtime of the device.
    // It would be called by the Timer1 (handles with DRV_TMR1).
    // The runtime will be reset to 0 every a period of time (not yet defined) 
}

void Timer3CallBack( void )
{
    // This function is used for counting the actual runtime of the device.
    // It would be called by the Timer1 (handles with DRV_TMR1).
    // The runtime will be reset to 0 every a period of time (not yet defined) 
}
/*
 Send a trigger Impuls to ouput pin (DISO4 - B4) every 10ms
 */
void Timer10msCallBackTrigger (void) {
    PLIB_PORTS_PinToggle(PORTS_ID_0, PORT_CHANNEL_B, PORTS_BIT_POS_4); 
}
// *****************************************************************************
// *****************************************************************************
// Section: Timer State Machine 
// *****************************************************************************
// *****************************************************************************
char timerService(void)
{
    switch (timerState)
    {

        /* Initial state is to create the timer object for periodic alarm */
        case TIMER_STATE_TIMER_OBJECT_CREATE:
        {
            /*SYS_TMR_CallbackPeriodic ( 250, 0, ISR_Callback_2 );
            timerData.tmrServiceHandle = SYS_TMR_ObjectCreate(APP_LED_BLINK_DELAY, 1, TimerCallBack, SYS_TMR_FLAG_PERIODIC);
            if(SYS_TMR_HANDLE_INVALID != timerData.tmrServiceHandle)
            {
                timerData.timerState = TIMER_STATE_IDLE;
            }*/
            //1sec timer
            //DRV_TMR0_Start();
                        
            timerState = TIMER_STATE_IDLE;
            break;
        }
        
        case TIMER_STATE_START:
            //Blinking Status LED while ADS conversion is running with Timer1CallBack() [in app.c]
            //Meanwhile, EEPROM writing
            DRV_TMR0_Start();
            //Start the runtime counter
            DRV_TMR1_Start();
            DRV_TMR2_Start();
            // PWM -> causes spikes in signal?!
            // no OC -> no LED toggling at the moment
            DRV_TMR3_Start();
            
            //START OC
            DRV_OC0_Start(); //OC_ID_1
            DRV_OC1_Start(); //OC_ID_1
            PLIB_OC_PulseWidth16BitSet(OC_ID_GREEN, OC_MAX_GREEN);
            PLIB_OC_PulseWidth16BitSet(OC_ID_YELLOW, OC_MAX_YELLOW);

            //DRV_OC1_Start();
            //runtimeData.current = 0;
            timerState = TIMER_STATE_IDLE;
            break;
            
        case TIMER_STATE_STOP:
            //Stop Status LED blinking and EEPROM writing
            DRV_TMR0_Stop();
            //Stop runtime counter and reset it to 0
            DRV_TMR1_Stop();
            DRV_TMR2_Stop();
            DRV_TMR3_Stop();
            //runtimeData.current = 0;
            //Turn Status LED on for stand by mode
            timerState = TIMER_STATE_IDLE;
            break;

        /* LED will be toggled in Timer Callback function, 
         * so nothing is there to be done in this state */
        case TIMER_STATE_IDLE:
        {
            break;
        }
        
        /* Should not come here during normal operation */
        default:
        {
            PLIB_ASSERT(false , "unknown application state");

            break;
        }

    }
}